<html><head><title>OSWorkflow Workflow Concepts</title></head><body><ul>

<li>Back to 
<a href="Documentation.html">OSWorkflow Documentation</a></li>
</ul>
<p></p>OSWorkflow is very unique compared to other workflow engines one might be familiar with. In order to completely grasp OSWorkflow and properly harness the features available, it is important that one understand the core concepts that form the foundation for OSWorkflow.

<h3>Steps, Status, and Actions
</h3>
<p></p>Any particular 
<i>workflow instance</i> can have one or more 
<i>current steps</i> at any given moment. Every current step has a 
<i>status value</i> associated to it. Status values of the current steps constitute 
<i>workflow status</i> for that workflow instance. 
<b>The actual status values are entirely up to the application developer and/or project manager</b>. A status value can be, for example "Underway", or "Queued".
<p></p>For the workflow to progress, a 
<i>transition</i> must take place in the finite state machine that represents a workflow instance. Once a step is completed it can not be current anymore. Usually a new current step is created immediately thereafter, which keeps the workflow going. The final status value of the completed step is set by the 
<b>old-status</b> attribute. It happens just before the transition to another step. 
<i>Old-status</i> must already be defined when a new transition takes place in the workflow. 
<i>It can be any value you please, but "Finished" usually works fine for most applications</i>.
<p></p>
<i>Transition</i> itself is a result of an 
<i>action</i>. A step may have many actions connected to it. Which particular action will be launched is determined by the end user, external event or automatically by a trigger. Depending on the action accomplished, a certain transition takes place. Actions can be restricted to particular groups and users or current state of the workflow. Each action must have one 
<i>unconditional result</i> (default) and zero or more 
<i>conditional results</i>.

<h3>Results, Joins, and Splits
</h3>
<p></p>1.1. Unconditional Result
<p></p>For every action, it is required that there exist one result, called the unconditional-result. A result is nothing more than a series of directives that tell OSWorkflow what the next task to do is. This involves making a transition from one state to the next state(s) in the state machine that makes up a given workflow.
<p></p>1.2. Conditional Results
<p></p>A conditional result is an extension of an unconditional result. It is identical, except for the fact that it requires one or more additional sub-elements: 
<b>condition</b>. The first conditional result that evaluates to true (using the types 
<b>AND</b> or 
<b>OR</b>) will dictate the transition that takes place due to the result of any given action taken by the user. Additional information regarding conditions can be found below.
<p></p>1.3. There are three different results (conditional or unconditional) that can occur:

<ul>

<li>A new single step/status combo</li>

<li>A split in to two or more step/status combos</li>

<li>A join that joins together this transition as well as others to a new single step/status combo</li>
</ul>
<p></p>Depending on what kind of behavior you are looking for, your XML workflow descriptor will look different. Please read the DTD (which provides documentation as well) in 
<span></img>
<a href="http://www.opensymphony.com/osworkflow/workflow_2_5.dtd">Appendix A</a></span> for more information. 
<b>One caveat: currently a split or a join cannot result in an immediate split or join again</b>.
<p></p>1.3.1. A single step/status result can be specified simply by:
<p></p>
<div>
<pre>&#60;unconditional&#45;result old&#45;status=
<span>"Finished"</span> step=
<span>"2"</span> status=
<span>"Underway"</span> owner=
<span>"$&#123;someOwner&#125;"</span>/&#62;</pre></div>
<p></p>If the status is not Queued, then a third requirement is the owner of the new step. Besides specifying information about the next state, results also can specify 
<i>validators</i> and 
<i>post-functions</i>. These will be discussed below.
<p></p>1.3.2. Splitting from one state to multiple states can be achieved by:
<p></p>
<div>
<pre>&#60;unconditional&#45;result split=
<span>"1"</span>/&#62;
...
&#60;splits&#62;
  &#60;split id=
<span>"1"</span>&#62;
    &#60;unconditional&#45;result old&#45;status=
<span>"Finished"</span> step=
<span>"2"</span> status=
<span>"Underway"</span> owner=
<span>"$&#123;someOwner&#125;"</span>/&#62;
    &#60;unconditional&#45;result old&#45;status=
<span>"Finished"</span> step=
<span>"2"</span> status=
<span>"Underway"</span> owner=
<span>"$&#123;someOtherOwner&#125;"</span>/&#62;
  &#60;/split&#62;
&#60;/splits&#62;</pre></div>
<p></p>1.3.3. Joins are the most complex cases. A typical join might look like:
<p></p>
<div>
<pre>&#60;!&#45;&#45; 
<span>for</span> step id 6 &#45;&#45;&#62;
&#60;unconditional&#45;result join=
<span>"1"</span>/&#62;
...
&#60;!&#45;&#45; 
<span>for</span> step id 8 &#45;&#45;&#62;
&#60;unconditional&#45;result join=
<span>"1"</span>/&#62;
...
&#60;joins&#62;
	&#60;join id=
<span>"1"</span>&#62;
		&#60;join id=
<span>"1"</span>&#62;
			&#60;conditions type=
<span>"AND"</span>&#62;
				&#60;condition type=
<span>"beanshell"</span>&#62;
					&#60;arg name=
<span>"script"</span>&#62;
					
<span>"Finished"</span>.equals(jn.getStep(6).getStatus() 
					&& 
<span>"Finished"</span>.equals(jn.getStep(8).getStatus())
					&#60;/arg&#62;
				&#60;/condition&#62;
			&#60;/conditions&#62;
		&#60;/join&#62;
		&#60;unconditional&#45;result old&#45;status=
<span>"Finished"</span> status=
<span>"Underway"</span> owner=
<span>"test"</span> step=
<span>"2"</span>/&#62;
	&#60;/join&#62;
&#60;/joins&#62;</pre></div>
<p></p>The above might seem somewhat cryptic, but the main thing to notice is that the 
<b>condition element</b> uses a special variable 
<b>"jn"</b> that can be used to make up expressions that determine when the join actually occurs. Essentially, this expression statement says 
<b>"proceed with the join when the steps with IDs 6 and 8 that are transitioning to this join have a status of Finished".</b> 

<h3>External Functions
</h3>
<p></p>OSWorkflow defines a standard way for external business logic and services to be defined and executed. This is accomplished by using "functions". A function usually encapsulates functionality that is external to the workflow instance itself, perhaps related to updating an external entity or system with workflow information, or notifying an external system regarding a change in workflow status.
<p></p>
<i>There are two types of functions: pre and post step functions.</i>
<p></p>Pre functions are functions that are executed before the workflow makes a particular transition. An example is a pre function that sets up the name of the caller to use as the result for the state change that is about to take place. Another example of a pre-function is a function that updates the most recent caller of an action. Both of these are provided as standard utility functions that are very useful for practical workflows.
<p></p>Post functions have the same range of applicability as pre functions, except that they are executed after the state change has taken place. An example of a post function is one that sends out an email to interested parties that the workflow has had a particular action performed on it. For example, when a document in the 'research' step has a 'markReadyForReview' action taken, the reviewers group is emailed.
<p></p>There are many reasons for including pre and post functions. One is that if the user were to click the "done" button twice and to send out two "execute action" calls, and that action had a pre function that took a long time to finish, then it is possible the long function could get called multiple times, because the transition hasn't been made yet, and OSWorkflow thinks the second call to perform the action is valid. So changing that function to be a post function is what has to happen. 
<i>Generally pre functions are for simple, quick executions, and post are where the "meat" goes.</i>
<p></p>You can find more information on 
<a href="Functions.html">OSWorkflow Functions</a>.

<h3>Trigger Functions
</h3>
<p></p>Trigger functions are just like any other function, except that they aren't associated with only one action. They are also identified with a unique ID that is used at a later time (when a trigger is fired) to be executed by the Quartz job scheduler (or any other job scheduler). These functions usually run under the context of a system user and not a regular user working in the workflow. Trigger functions are invoked by using the OSWorkflow API from an outside source, such as a job scheduler like Quartz.
<p></p>You can find more information on 
<a href="trigger_function.html">trigger function</a>.

<h3>Validators
</h3>
<p></p>A validator is nothing more than some code that validates the input that can be paired with an action. If the input is deemed to be valid, according to the validator, the action will be executed. If the input is invalid, the 
<i>InvalidInputException</i> will be thrown back to the calling client -- usually a JSP or servlet.
<p></p>Validators follow many of the same rules as Functions. You can find out more about 
<a href="Validators.html">OSWorkflow Validators</a>.

<h3>Registers
</h3>
<p></p>A register is a helper function that returns an object that can be used in Functions for easy access to common objects, especially entities that revolve around the workflow. The object being registered can be any kind of object. Typical examples of objects being registered are: Document, Metadata, Issue, and Task. This is strictly for convenience and does not add any extra benefit to OSWorkflow besides making the developer's life much simpler. Here is an example of a register:
<p></p>
<div>
<pre>&#60;registers&#62;
	&#60;register name=
<span>"doc"</span> class=
<span>"com.acme.DocumentRegister"</span>/&#62;
&#60;/registers&#62;
...
&#60;results&#62;
	&#60;result condition=
<span>"doc.priority == 1"</span> step=
<span>"1"</span> status=
<span>"Underway"</span> owner=
<span>"$&#123;someManager&#125;"</span>/&#62;
	&#60;unconditional&#45;result step=
<span>"1"</span> status=
<span>"Queued"</span>/&#62;
&#60;/results&#62;
...</pre></div>

<h3>Conditions
</h3>
<p></p>Conditions, just like validators, registers, and functions, can be implemented in a variety of languages and technologies. Conditions can be grouped together using 
<b>AND</b> or 
<b>OR</b> logic. Any other kind of complex login must be implemented by the workflow developer. Conditions usually associated with conditional results, where a result is executed based on the conditions imposed on it being satisfied.
<p></p>Conditions are very similar to functions except that they return 
<b>boolean</b> instead of 
<b>void</b>. You can find out more about 
<a href="Conditions.html">OSWorkflow Conditions</a>.

<h3>Variable Interpolation
</h3>
<p></p>In all functions, conditions, validators, and registers it is possible to provide a set of 
<b>args</b> to the code of choice. These args are translated to the 
<b>args Map</b> that is discussed in further detail later on. Likewise the 
<b>status, old-status, and owner elements</b> in the workflow descriptor are also all parsed for variables to be dynamically converted. A variable is identified when it looks like 
<b>${foo}</b>. OSWorkflow recognizes this form and first looks in the 
<b>transientVars</b> for the key foo. If the key does not exist as a transient variable, then then  
<b>propertySet</b> is searched. If the propertyset does not contain the specified key either, then the entire variable is converted to an empty String.
<p></p>One thing of particular importance is that in the case of 
<b>args</b>, if the variable is the only argument, the argument will not be of type String, but instead whatever the variable type is. However, if the arg is a mix of characters and variables, the entire argument is converted to String no matter what. That means the two arguments below are very different in that foo is a Date object and bar is a String:
<p></p>
<div>
<pre>&#60;arg name=
<span>"foo"</span>&#62;$&#123;someDate&#125;&#60;/arg&#62;
&#60;arg name=
<span>"bar"</span>&#62; $&#123;someDate&#125; &#60;/arg&#62; &#60;!&#45;&#45; note the extra spaces &#45;&#45;&#62;</pre></div>

<h3>Permissions and Restrictions
</h3>
<p></p>
<i>Permissions</i> can be assigned to users and/or groups based on the state of the workflow instance. These permissions are unrelated to the functionality of the workflow engine, but they are useful to have for applications that implement OSWorkflow. For example, a document management system might have the permission name "file-write-permission" enabled for a particular group only during the "Document Edit" stage of the workflow. That way your application can use the API to determine if files can be modified or not. This is useful as there could be a number of states within the workflow where the "file-write-permission" is applicable, so instead of checking for specific steps or conditions, the check can simply be made for a particular permission.
<p></p>Permissions and actions both use the concept of 
<i>restrictions</i>. 
<b>A restriction is nothing more than one or more conditions embedded inside a restrict-to element.</b> 

<h3>Auto actions
</h3>
<p></p>Sometimes it is desirable to have an action performed automatically, based on specific conditions. This is useful for example when trying to add automation to a workflow. In order to achieve this, an attribute of 
<b>auto="true"</b> will have to be added to the specific action. The workflow engine will then evaluate the conditions and restrictions on the action, and if they are matched and the workflow 
<b>could</b> perform the action, then it automatically does so.

<h3>Integrating with Abstract Entities
</h3>
<p></p>Because OSWorkflow is not an out-of-the-box solution, some development work is required to make your project work correctly with OSWorkflow. It is recommended that your core entity, such as "Document" or "Order", be given a new attribute: 
<i>workflowId</i>. That way when a new Document or Order is created, it can be associated with a workflow instance also. Then your code can look up that workflow instance and retrieve workflow information and/or issue workflow actions via the OSWorkflow API.

<h3>Workflow Instance State (Available in OSWorkflow 2.6+)
</h3>
<p></p>Sometimes it is helpful to specify a state to the workflow instance as a whole, independent to its progression or its steps. OSWorkflow offers a number of such "meta-states" that a workflow instance can be in. These are 
<b>CREATED</b>, 
<b>ACTIVATED</b>, 
<b>SUSPENDED</b>, 
<b>KILLED</b>, and 
<b>COMPLETED</b>. When a workflow instance is first created, it is in the 
<b>CREATED</b> state. Then as soon as an action is performed on it, it moves automatically to the 
<b>ACTIVATED</b> state. If the caller does not explicitly alters the instance state, the workflow will remain in this state until it is unambigiously completed. This is defined to be the case when the workflow cannot possibly perform any further actions. In this case, the workflow will automatically move to the 
<b>COMPLETED</b> state.
<p></p>However, while the workflow is in the 
<b>ACTIVATED</b> state, a caller can termined or suspend the workflow (set the state to 
<b>KILLED</b> or 
<b>SUSPENDED</b>). A terminated workflow will not be able to progress any further, and will remain in the state it was in at the time of termination forever. A workflow that has been suspended will be 'frozen' and no actions can be performed on it, until it is explicitly returned back to the 
<b>ACTIVATED</b> state.
</div></body></html>